[
    {
        "id": "flash_control",
        "content": "# DeveloperTools\nThis is a collection of various script and other useful software to help speed up the development process.\n"
    },
    {
        "id": "system-service",
        "content": "# Overview\nThis repo contains Android code for the System Service and an API that can be used ot access it. The\nSystem Service in the System/ROM level will allow Gogo apps silent (no user input) access to parts of\nAndroid normally accessible to low-level system apps.\n\nBuild Notes:\nThe System Service requires a special android.jar and signed with the platform certificate.  It is\nincluded in this repo but can be build as described in wiki\nhttps://inside.gogoair.com/pages/viewpage.action?pageId=99652283\n\nThere is a seperate test App that can be used to manually test the system service. It can be found at\nthe following git repository.\nhttps://git.gogoair.com/wsb-android/system-service-sampleapp\n"
    },
    {
        "id": "skypulse-api",
        "content": "# skypulse-api\n\n## Testing\n\nThis section documents testing best practices.\n\n### Testing Lambdas\n\nLambdas can be tested by importing and invoking the handler function with test events.\n\n```\nimport { handler } from 'path/to/lambda';\ndescribe('lambda', () => {\n  test('should do something', async () => {\n    await expect(handler(TEST_EVENT), null, () => {}).resolves.toBe(TEST_EXPECTATION);\n  });\n});\n```\n\n### Events\n\nTest events represent a JSON structure that might be passed as an argument to the target lambda.  Events should be created to stress the logic of the lambda.\n\nBy convention, test events should be JSON files created in the mock directory of the form `test-<lambda>.condition.json` where lambda is the name of the lambda being tested and condition is a brief description of the part of the lambda that is being stressed.\n\nAn event might look like:\n```\n{\n  \"requestContext\": {\n    \"authorizer\": {\n      \"role\": \"admin\",\n      \"org\": \"my-org\",\n      \"principalId\": \"<user-external-id>\"\n    }\n  },\n  \"headers\": {\n    \"authorization\": \"Bearer localinvoke\",\n    \"x-api-key\": \"<api-key>\"\n  },\n  \"body\": \"{\\\"id\\\": \\\"4jsuiKBI2qpWxmkPiBobBU\\\", \\\"created\\\": null}\"\n}\n\n```\n\nThis event will be interpreted by the lambda handler logic which can then be used to make assertions in tests.\n\n### Mocking\n\nAny lambda that is being tested must mock the the DFPConfigurationManager at the top of the file:\n\n```\njest.mock('../../classes/DFPConfigurationManager');\n```\n\nThis is a necessary because all lambdas use the configuration manager in some capacity through the lambda wrappers.\n\n***Set Configuration***\n\nSet configuration will mock the returned values of a hash of SSM parameters and bypass the network calls to AWS SSM Parameter Store.  Any SSM configurations that the lambda depends on must be mocked using the `setConfiguration` helper:\n\n```\nimport { setConfiguration } from '../../classes/DFPConfigurationManager';\njest.mock('../../classes/DFPConfigurationManager');\n\ndescribe('lambda', () => {\n  beforeAll(() => {\n    setConfiguration({\n      foo: 'bar'\n    });\n  });\n\n  test('should do something', async () => {\n    ...testing logic\n  });\n});\n```\n\nThe `setConfiguration` helper can be called in individual tests or in beforeAll/beforeEach blocks.\n\n### Testing API Lambda Exceptions\n\nThe API lambda implementations do not throw exceptions direcly from the handler so assertions against error conditions must use our response abstractions:\n\n```\nawait expect(handler(EVENT), null, () => {}).resolves.toStrictEqual(\n  new DFPAPILambdaJSONErrorResponse(\n    new DFPAPILambdaError('some client error', 400),\n  ),\n);\n```\n\n### Logging in Tests\n\nJest uses a variety of configurations to control console output and it can be difficult to get basic logging in place when building the tests.\n\nThis has been a reliable method for circumventing Jest shenanigans:\n```\nconst console = require('console');\n```\n\n### Notes\n\n* Handlers are all invoked asynchronously so they must use the async/await expect syntax documented above.\n"
    },
    {
        "id": "offload-messaging",
        "content": "# README #\n\nThis README would normally document whatever steps are necessary to get your application up and running.\n\n### What is this repository for? ###\n\n* Quick summary\n* Version\n* [Learn Markdown](https://bitbucket.org/tutorials/markdowndemo)\n\n### How do I get set up? ###\n\n* Summary of set up\n* Configuration\n* Dependencies\n* Database configuration\n* How to run tests\n* Deployment instructions\n\n### Contribution guidelines ###\n\n* Writing tests\n* Code review\n* Other guidelines\n\n### Who do I talk to? ###\n\n* Repo owner or admin\n* Other community or team contact"
    },
    {
        "id": "developertools",
        "content": "# DeveloperTools\nThis is a collection of various script and other useful software to help speed up the development process.\n"
    }
]